// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

/*

This file is automatically generated by T4 template

*/

<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>

using System;
using System.Runtime.CompilerServices;
using System.Numerics;

// casting into non-nullable, unboxing from nullable  
#pragma warning disable 8600
#pragma warning disable 8605

<#
    // T4 is old enough to not have value tuple
    
    var typesFullNames = new [] {
            "Half",    
            "Float",  
            "Double",  
            "Decimal", 
            "SByte",   
            "Byte",    
            "Short",   
            "UShort", 
            "Int",
            "UInt",
            "Long",
            "ULong",
            "Complex",
            "BigInteger"
        };
    
    var types = new [] {
            "Half",   
            "float",  
            "double", 
            "decimal",
            "sbyte",  
            "byte",   
            "short",  
            "ushort", 
            "int",
            "uint",
            "long",
            "ulong",
            "Complex",
            "BigInteger"
        };
    
    var intermediateCasts = new System.Collections.Generic.Dictionary<string, string>();
    // for some reason rider also complains about inline initialization
    intermediateCasts["decimal_Half"] = "double";
    intermediateCasts["Half_decimal"] = "float";
    intermediateCasts["Half_Complex"] = "float";
    intermediateCasts["Complex_Half"] = "double";
    intermediateCasts["Half_BigInteger"] = "float";
    intermediateCasts["BigInteger_Half"] = "double";
    
    var len = types.Length;
#>

namespace Silk.NET.Maths
{
    /// <summary>
    /// A collection of operations for working with scalar numeric values.
    /// Includes methods like the ones found in <see cref="Math"/> and more.
    /// Supports <#= string.Join(", ", types.Select(type => $"<see cref=\"{type}\" />")) #>
    /// </summary>
    /// <seealso cref="Scalar{T}"/>
    public partial class Scalar
    {
        /// <summary>
        /// Convert <paramref name="val"/> from <typeparamref name="TFrom"/> to <typeparamref name="TTo"/>
        /// </summary>
        /// <param name="val">The value to convert</param>
        /// <typeparam name="TFrom">The type converted from</typeparam>
        /// <typeparam name="TTo">The type converted into</typeparam>
        /// <remark>
        /// While in most cases the types can be just explicitly casted,
        /// sometimes there is an intermediate cast to float or double.
        /// </remark>
        /// <remark>
        /// In case of <see cref="Complex" /> we only consider the real part.
        /// </remark>
        /// <returns>The converted value</returns>
        [MethodImpl(MaxOpt)]
        public static TTo As<TFrom, TTo>(TFrom val) where TFrom : notnull where TTo : notnull
        {   
            // We rejigged this code a bit to be a bit more strategic about its specialization branch as to not
            // exceed RyuJIT's inlining/codegen budgets. In doing this, Mono apparently started producing invalid
            // arm assembly, so we now maintain two paths: one for Mono, and one for CoreCLR. The CoreCLR one should
            // really be preferred.
#if ANDROID || IOS

            return FromHalfToHalf(val);
            
<# for (var i = 0; i < len; i++) { #>
<# for (var j = 0; j < len; j++) {  
#>

            [MethodImpl(MaxOpt)]
            static TTo From<#= typesFullNames[i] #>To<#= typesFullNames[j] #>(TFrom val)
            {
                if (typeof(TFrom) == typeof(<#= types[i] #>) && typeof(TTo) == typeof(<#= types[j] #>))
                {
<# 
var intermediateType = "";
if (intermediateCasts.TryGetValue($"{types[i]}_{types[j]}", out var res))
    intermediateType = $" ({res})";

#>
<# if (types[i] == "Complex") { #>
                    return (TTo) (object) (<#= types[j] #>)<#= intermediateType #> ((<#= types[i] #>) (object) val).Real;
<# } else { #>
                    return (TTo) (object) (<#= types[j] #>)<#= intermediateType #> (<#= types[i] #>) (object) val;
<# } #>
                }
                
<# 
            var jNext = (j + 1) % len;
            var iNext = i + (jNext == 0 ? 1 : 0);
            if (iNext == len) {
            #>
                ThrowUnsupportedType();
                return default!;
<# } else { #>
                return From<#= typesFullNames[iNext] #>To<#= typesFullNames[jNext] #>(val);
<# } #>
            }    
<# } #>
<# } #>
#else
<# for (var i = 0; i < len; i++) { #>
            if (typeof(TFrom) == typeof(<#= types[i] #>))
            {
                return From<#= typesFullNames[i] #>((<#= types[i] #>) (object) val);
            }

            [MethodImpl(MaxOpt)]
            static TTo From<#= typesFullNames[i] #>(<#= types[i] #> val)
            {
<# for (var j = 0; j < len; j++) {  
#>
                if (typeof(TTo) == typeof(<#= types[j] #>))
                {
<# 
var intermediateType = "";
if (intermediateCasts.TryGetValue($"{types[i]}_{types[j]}", out var res))
    intermediateType = $" ({res})";

#>
<# if (types[i] == "Complex") { #>
                    return (TTo) (object) (<#= types[j] #>)<#= intermediateType #> val.Real;
<# } else { #>
                    return (TTo) (object) (<#= types[j] #>)<#= intermediateType #> val;
<# } #>
                }
<# } #>

                ThrowUnsupportedType();
                return default!;
            }

<# } #>
            ThrowUnsupportedType();
            return default!;
#endif
        }
    }
}